From 9bfc5d928c845fe760db170e7deb7c23c1d4c094 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Mon, 14 Apr 2014 16:43:05 -0400
Subject: [PATCH 06/18] pci-assign: Make host irq to vcpu affinity

    Based upon qemu-kvm commit 1ba2612d057ea34f505bb1d0ee9601aef705ca6d
    [
     If a guest sets the affinity of a assigned device interrupt to a
     particular vcpu and the vcpu is pinned to a physical core, then direct
     the host interrupt to that physical core to avoid IPIs.

     Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    ]

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
[ywei: fix context conflicts in:
	include/standard-headers/linux/pci_regs.h
	hw/i386/kvm/pci-assign.c
]
Signed-off-by: Yunguo Wei <yunguo.wei@windriver.com>
[Adjust code context]
Upstream-Status: Pending
Signed-off-by: He Zhe <zhe.he@windriver.com>
---
 cpus.c                                    |  5 ++
 hw/i386/kvm/pci-assign.c                  | 89 ++++++++++++++++++++++++++++++-
 include/standard-headers/linux/pci_regs.h |  3 ++
 include/sysemu/cpus.h                     |  1 +
 linux-headers/linux/kvm.h                 |  7 +++
 5 files changed, 103 insertions(+), 2 deletions(-)

diff --git a/cpus.c b/cpus.c
index 2ab447ad..8bbd8dc5 100644
--- a/cpus.c
+++ b/cpus.c
@@ -918,6 +918,11 @@ static void qemu_kvm_init_cpu_signals(CPUState *cpu)
 static cpu_set_t vcpu_affinity[1024];
 static int vcpu_priority[1024];
 
+cpu_set_t *qemu_kvm_vcpu_get_affinity(int vcpu)
+{
+	return vcpu_affinity + vcpu;
+}
+
 static void qemu_kvm_vcpu_sched_init(CPUState *env)
 {
     int idx = env->cpu_index;
diff --git a/hw/i386/kvm/pci-assign.c b/hw/i386/kvm/pci-assign.c
index 87dcbdd5..8d33b68b 100644
--- a/hw/i386/kvm/pci-assign.c
+++ b/hw/i386/kvm/pci-assign.c
@@ -36,6 +36,7 @@
 #include "hw/pci/msi.h"
 #include "kvm_i386.h"
 #include "hw/pci/pci-assign.h"
+#include "sysemu/cpus.h"
 
 /* From linux/ioport.h */
 #define IORESOURCE_IO       0x00000100  /* Resource type */
@@ -75,8 +76,10 @@ typedef struct AssignedDevRegion {
     PCIRegion *region;
 } AssignedDevRegion;
 
-#define ASSIGNED_DEVICE_PREFER_MSI_BIT  0
-#define ASSIGNED_DEVICE_SHARE_INTX_BIT  1
+
+#define ASSIGNED_DEVICE_PREFER_MSI_BIT		0
+#define ASSIGNED_DEVICE_SHARE_INTX_BIT		1
+#define ASSIGNED_DEVICE_VCPU_AFFINITY_BIT	2
 
 #define ASSIGNED_DEVICE_PREFER_MSI_MASK (1 << ASSIGNED_DEVICE_PREFER_MSI_BIT)
 #define ASSIGNED_DEVICE_SHARE_INTX_MASK (1 << ASSIGNED_DEVICE_SHARE_INTX_BIT)
@@ -119,6 +122,8 @@ typedef struct AssignedDevice {
     uint8_t emulate_config_write[PCI_CONFIG_SPACE_SIZE];
     int msi_virq_nr;
     int *msi_virq;
+    int msix_host_irqs[64];
+    uint32_t msix_host_affinity[64];
     MSIXTableEntry *msix_table;
     hwaddr msix_table_addr;
     uint16_t msix_table_size;
@@ -949,6 +954,10 @@ static void assigned_dev_update_irq_routing(PCIDevice *dev)
     }
 }
 
+static void kvm_msix_update_affinity(AssignedDevice *dev, int entry, int dest);
+
+static bool assigned_dev_msix_masked(MSIXTableEntry *entry);
+
 static void assigned_dev_update_msi(PCIDevice *pci_dev)
 {
     AssignedDevice *assigned_dev = PCI_ASSIGN(pci_dev);
@@ -1137,6 +1146,22 @@ static void assigned_dev_update_msix(PCIDevice *pci_dev)
         assigned_dev->intx_route.mode = PCI_INTX_DISABLED;
         assigned_dev->intx_route.irq = -1;
         assigned_dev->assigned_irq_type = ASSIGNED_IRQ_MSIX;
+        {
+            /* Assign affinity to all the enabled irqs
+               for the assigned device.
+             */
+            MSIXTableEntry *entry = assigned_dev->msix_table;
+            int i;
+
+            for (i = 0; i < assigned_dev->msix_max; i++, entry++) {
+                if (assigned_dev_msix_masked(entry)) {
+                    continue;
+                }
+                kvm_msix_update_affinity(assigned_dev, i,
+                   (entry->addr_lo & MSI_ADDR_DEST_ID_MASK)
+                   >> MSI_ADDR_DEST_ID_SHIFT);
+            }
+        }
     } else {
         Error *local_err = NULL;
 
@@ -1154,6 +1179,14 @@ static uint32_t assigned_dev_pci_read_config(PCIDevice *pci_dev,
     uint32_t virt_val = pci_default_read_config(pci_dev, address, len);
     uint32_t real_val, emulate_mask, full_emulation_mask;
 
+    if (assigned_dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {
+        uint32_t msi_start = pci_dev->msi_cap;
+        uint32_t msi_end = msi_start + PCI_MSI_DATA_64 + 3;
+
+	if (address >= msi_start && (address + len) < msi_end)
+            return virt_val;
+    }
+
     emulate_mask = 0;
     memcpy(&emulate_mask, assigned_dev->emulate_config_read + address, len);
     emulate_mask = le32_to_cpu(emulate_mask);
@@ -1532,6 +1565,53 @@ static int assigned_device_pci_cap_init(PCIDevice *pci_dev, Error **errp)
     return 0;
 }
 
+static int assign_query_msix_irq(AssignedDevice *dev, int entry)
+{
+    if (dev->msix_host_irqs[entry] <= 0) {
+        struct kvm_assigned_msix_query_irq query;
+
+        query.assigned_dev_id = dev->dev_id;
+        query.entry = entry;
+        dev->msix_host_irqs[entry] =
+                  kvm_vm_ioctl(kvm_state, KVM_ASSIGN_QUERY_IRQ, &query);
+    }
+    return dev->msix_host_irqs[entry];
+}
+
+static void kvm_msix_update_affinity(AssignedDevice *dev, int entry, int dest)
+{
+    char buf[16], fnam[256];
+    int irq, fd, i;
+    cpu_set_t *msk;
+
+    if (!(dev->features & ASSIGNED_DEVICE_VCPU_AFFINITY_BIT))
+        return;
+
+    irq = assign_query_msix_irq(dev, entry);
+    if (irq <= 0)
+        return;
+
+    msk = qemu_kvm_vcpu_get_affinity(dest);
+    if (!CPU_COUNT(msk))
+        return;
+
+    for (i = 0; i < CPU_SETSIZE; i++) {
+        if (CPU_ISSET(i, msk))
+             break;
+    }
+
+    sprintf(buf, "%d\n", i);
+    sprintf(fnam, "/proc/irq/%d/smp_affinity_list", irq);
+    fd = open(fnam, O_RDWR);
+    if (fd < 0)
+        return;
+    i = write(fd, buf, strlen(buf));
+    if (i < 0)
+        perror("irq affinity setting failed");
+    close(fd);
+    dev->msix_host_affinity[entry] = dest;
+}
+
 static uint64_t
 assigned_dev_msix_mmio_read(void *opaque, hwaddr addr,
                             unsigned size)
@@ -1606,6 +1686,7 @@ static void assigned_dev_msix_mmio_write(void *opaque, hwaddr addr,
                     error_report("Error updating irq routing entry (%d)", ret);
                 }
                 kvm_irqchip_commit_routes(kvm_state);
+                kvm_msix_update_affinity(adev, i, (entry->addr_lo & MSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT);
             }
         }
     }
@@ -1813,6 +1894,8 @@ static void assigned_realize(struct PCIDevice *pci_dev, Error **errp)
         goto assigned_out;
     }
 
+    memset(dev->msix_host_affinity, 0xff, sizeof(dev->msix_host_affinity));
+
     assigned_dev_load_option_rom(dev);
 
     return;
@@ -1852,6 +1935,8 @@ static Property assigned_dev_properties[] = {
                     ASSIGNED_DEVICE_PREFER_MSI_BIT, false),
     DEFINE_PROP_BIT("share_intx", AssignedDevice, features,
                     ASSIGNED_DEVICE_SHARE_INTX_BIT, true),
+    DEFINE_PROP_BIT("vcpuaffine", AssignedDevice, features,
+                        ASSIGNED_DEVICE_VCPU_AFFINITY_BIT, true),
     DEFINE_PROP_STRING("configfd", AssignedDevice, configfd_name),
     DEFINE_PROP_END_OF_LIST(),
 };
diff --git a/include/standard-headers/linux/pci_regs.h b/include/standard-headers/linux/pci_regs.h
index 40409512..bf593dd9 100644
--- a/include/standard-headers/linux/pci_regs.h
+++ b/include/standard-headers/linux/pci_regs.h
@@ -309,6 +309,9 @@
 #define PCI_MSI_MASK_64		16	/* Mask bits register for 64-bit devices */
 #define PCI_MSI_PENDING_64	20	/* Pending intrs for 64-bit devices */
 
+#define MSI_ADDR_DEST_ID_SHIFT	12
+#define MSI_ADDR_DEST_ID_MASK	0x00ffff0
+
 /* MSI-X registers */
 #define PCI_MSIX_FLAGS		2	/* Message Control */
 #define  PCI_MSIX_FLAGS_QSIZE	0x07FF	/* Table size */
diff --git a/include/sysemu/cpus.h b/include/sysemu/cpus.h
index 8db8a3dd..baa8c012 100644
--- a/include/sysemu/cpus.h
+++ b/include/sysemu/cpus.h
@@ -27,6 +27,7 @@ void cpu_synchronize_all_post_init(void);
 
 void qtest_clock_warp(int64_t dest);
 void vcpu_parse(const char *optarg);
+cpu_set_t *qemu_kvm_vcpu_get_affinity(int vcpu);
 
 #ifndef CONFIG_USER_ONLY
 /* vl.c */
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index e60e21ba..55e25aa4 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -1037,6 +1037,8 @@ struct kvm_arm_device_addr {
 	__u64 addr;
 };
 
+#define KVM_ASSIGN_QUERY_IRQ      _IO(KVMIO,  0xe8)
+
 /*
  * Device control API, available with KVM_CAP_DEVICE_CTRL
  */
@@ -1313,4 +1315,9 @@ struct kvm_assigned_msix_entry {
 	__u16 padding[3];
 };
 
+struct kvm_assigned_msix_query_irq {
+	__u32 assigned_dev_id;
+	__u32 entry;
+};
+
 #endif /* __LINUX_KVM_H */
-- 
2.11.0

