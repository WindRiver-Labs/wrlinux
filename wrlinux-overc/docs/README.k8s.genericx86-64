             Kubernetes on OverC on the genericx86-64 BSP
             --------------------------------------------

Introduction
---

The following provides information for building and running Kubernetes
on OverC on the genericx86-64 BSP. Additional information can be found
in the Wind River Linux documentation 'Wind River Linux OverC
Virtualization Features Guide'. Adjust the steps according to your
desired BSP should it not be the genericx86-64 BSP.


Building
---
1) Configure your build area using setup.sh:
  %> ./wrlinux-setup.sh --machines genericx86-64 \
       --distros wrlinux-overc \
       --dl-layers \
       --no-recommend

2) Run the environment-setup script from the project directory:
  %> . ./environment-setup-x86_64-wrlinuxsdk-linux

3) Run the oe-init-build-env script:
  %> . ./oe-init-build-env
or with a build directory specified
  %> . ./oe-init-build-env <newBuildDir>

4) Complete the build:
  %> bitbake cube-vrf cube-dom0 cube-essential cube-k8s-node \
     cube-builder-initramfs


Create an Image
---
Starting in your build directory you created above.

Before you start be sure you have 'btrfs-progs' installed for your
host distro:
  %> sudo apt-get install btrfs-progs

1) Build native tools required to run the installer:
  %> bitbake grub-native jq-native parted-native dosfstools-native btrfs-tools-native qemu-system-native
  %> bitbake build-sysroots

2) Copy the OverC image configurations from the platform project directory:
  %> cp ../layers/wrlinux/wrlinux-overc/bin/* .

3) Edit the configuration to add the cube-k8s-node in place of cube-server.
  a) Replace cube-server with cube-k8s-node
  b) Adjust the cube-k8s-node attributes
    1) add 'type=system'
    2) remove 'cube.device.mgr=self'

  You can cut and paste the follow command to accomplish this:

  %> sed -i -e 's/cube-server\(.*\)cube.device.mgr=self/cube-k8s-node\1type=system/' \
            image-live.sh

4) Create a live or installer image. See the product documentation for more
   information. This procedure is not specific to this 'K8S on OverC' usecase.
   For example to build a disk image which can be used with QEMU or copied
   to a SD card or USB thumbdrive to boot a live install, do the following:
  %> sudo \
   PATH=$PWD/tmp/sysroots/x86_64/usr/bin:$PWD/tmp/sysroots/x86_64/usr/sbin:$PATH \
   ../overc-installer/sbin/cubeit --disk-size 15G --force \
   --config `pwd`/image-live.sh \
   --artifacts `pwd`/tmp/deploy/images/genericx86-64 boot.img


Example usecase - creating a K8S cluster with Weave and run an
                  example 'Hello World!" pod.
---

1) Start by installing Kubernetes API Server packages installed (kubeadm,
   kubectl, kubelet). For example using Ubuntu this might be done using
   the following commands:

  %> sudo apt-get update && apt-get install -y apt-transport-https \
      && curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg \
      | apt-key add -
  %> echo "deb http://apt.kubernetes.io/ kubernetes-xenial main" \
      > /etc/apt/sources.list.d/kubernetes.list
  %> sudo apt install kubeadm=1.15.3* kubectl=1.15.3* kubelet=1.15.3* \
         kubernetes-cni

   NOTE: The above instruction are only provided as an example and may
         vary depending on your version of Ubuntu and are not applicable
         for other Linux distributions.
   NOTE: Be sure to disable swap in the fstab and turn off swap
         via 'sudo swapoff -a' if it is currently on.

2) Initialize your Kubernetes cluster using 'kubeadm'
  %> rm -rf ~/.kube
  %> sudo kubeadm init  --kubernetes-version=1.15.3

   Be sure to cut and paste the instructions provided by the output
   of 'kubeadm' to setup ~/.kube for your user. And save the 'join'
   text.

3) Setup Weave
  %> kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"

4) At this point ensure the Kubernetes API Server is up and running. You
   can run commands like 'kubectl get pods --all-namespaces' and
   'kubectl get nodes' to ensure all pods are 'Running' and the
   K8S API Server node STATUS is  'Ready'.

5) Start the OverC image on a device and ensure connectivity to the
   now running Kubernetes API Server.

6) Disable swap on the OverC node
  # swapoff -a

7) Weave will try to (re)create the directory /opt/cni/bin, however,
   OverC defines /opt/cni/bin as a link which will prevent Weave from
   properly running. To work around this we remove the link and instead
   create a copy of the link contents. Run the following commands on
   the OverC node
  # rm /opt/cni/bin
  # cp -a /usr/libexec/cni/ /opt/cni/bin

8) Cut and paste the join command from step (2) adding the option
   '--ignore-preflight-errors=all'

9) Edit the kubelet.yaml file to match the OverC configuration
   a) Disable cgroupsPerQOS
   b) Disable enforceNodeAllocatable

   You should be able to accomplish these changes with the
   following command on the OverC node.
  # sed -i -e 's/\(cgroupsPerQOS:\).*$/\1 false/' \
           -e 's/\(enforceNodeAllocatable:\).*/\1 []/' \
           -e '/-\ pods/d' /var/lib/kubelet/config.yaml

10) At this point the node STATUS should be 'Ready'. You can
    verify this on the K8S API Server with the command
    'kubectl get nodes'

11) Deploy the 'Hello World!' pod and expose the service.  From
    the K8S API Sever run the commands
   %> kubectl run hello-kubernetes --replicas=1 \
      --image=paulbouwer/hello-kubernetes:1.5 --port=8080
   %> kubectl expose deployment hello-kubernetes \
      --type=LoadBalancer --port=80 --target-port=8080 \
      --name=hello-kubernetes --external-ip <K8S API Server IP>

12) From a 3rd machine on the same network you should be able
    to open a web browser and using the IP Address of the K8S
    API Server as the URL retrieve the 'Hello World!' page.

    Alternatively you can use the command 'kubectl get services'
    to get the internal IP of the service. On the K8S API Sever
    you can then 'wget <service_ip>' to retrieve the 'Hello World!'
    page.
